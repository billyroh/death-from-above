<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font-family: Georgia, "Times New Roman", serif;
  color: #454545;
  margin: 0 auto;
  padding: 60px;
  max-width: 945px;
  min-width: 320px;
}

h1, h2 {
  font-weight: 300;
}

h1, h2, p {
}

.section {
  display: block;
}



/* Sparklines */

.country-label, .sparkline {
  width: 300px;
  float: left;
  float: left;
  margin-right: 10px;
}

.sparkline-wrapper {
  display: block;
  margin-bottom: 20px;
  height: 200px;
}

.sparkline {
  height: 150px;
  display: block;
}

.sparkline:last-child {
  margin-right: 0px;
}

.data-type-label {
  margin-bottom: 10px;
}

/* Map Stuff */

.map {
  width: 100%;
  height: 600px;
  display: block;
  border: 1px solid rgba(0, 0, 0, 0.3);
}

.background {
  fill: none;
  pointer-events: all;
}

.feature {
  fill: #ccc;
  /*cursor: pointer;*/
}

circle.sparkline {
  fill: #fff;
  stroke: #000;
  stroke-width: 2px;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.tooltip {
  width: 300px;
  height: 300px;
  background-color: red;
}

circle.strike, circle.timeline-circle {
  fill: rgb(200, 18, 18);
  opacity: 0.2;
  cursor: pointer;
  -webkit-transition: all 150ms;
  transition: all 150ms;
}

.feature.active {
  
}

.mesh {
  fill: none;
  stroke: #fff;
  stroke-width: 0.5px;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.country-name {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  fill: #000;
  opacity: 0.3;
  margin-left: -10px;
  font-size: 11px;
  text-transform: uppercase;
  cursor: default;
}

/* Timeline stuff */ 

.timeline {
  width: 100%;
  height: 30px;
  margin-top: 10px;
}

.timeline-by-country {
  width: 100%;
  height: 200px;
}

.axis path,
.axis line {
  fill: none;
  stroke: black;
  shape-rendering: crispEdges;
}

.y.axis path {
  stroke: none;
}

.x.axis path {
  /*stroke: none;*/
}

.axis text {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 11px;
  cursor: default;
}

circle.not-applicable {
  opacity: 0;
  /*display: none;*/
}

line {
  stroke: #000;
}

line.sparkline {
  stroke: #000;
}


/* Tooltip shit */

.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

</style>
<body>
<div class="text" id="intro">
  <h1>Death from Above</h1>
  <p>Mapping deaths from drone strikes.</p>
</div>
<div class="section" id="timeline-section">
  <h2>Timelines</h2>
  <p>Each circle corresponds to a single strike.</p>
  <div class="country-label-wrapper">
    <div class="country-label" id="Pakistan">Pakistan</div>
    <div class="country-label" id="Yemen">Yemen</div>
    <div class="country-label" id="Somalia">Somalia</div>
  </div>
  <div class="sparkline-wrapper" id="deaths">
    <div class="data-type-label">Overall Death Estimate</div>
    <svg class="sparkline" id="Pakistan"></svg>
    <svg class="sparkline" id="Yemen"></svg>
    <svg class="sparkline" id="Somalia"></svg>
  </div>
  <div class="sparkline-wrapper" id="civilians">
    <div class="data-type-label">Civilian Death Estimate</div>
    <svg class="sparkline" id="Pakistan"></svg>
    <svg class="sparkline" id="Yemen"></svg>
    <svg class="sparkline" id="Somalia"></svg>
  </div>
  <div class="sparkline-wrapper" id="children">
    <div class="data-type-label">Child Death Estimate</div>
    <svg class="sparkline" id="Pakistan"></svg>
    <svg class="sparkline" id="Yemen"></svg>
    <svg class="sparkline" id="Somalia"></svg>
  </div>
<!-- </div>
<div class="data-type-selector-wrapper">
  <select class="data-type-selector">
    <option class="data-type" value="deaths_max" selected="selected">Maximum Death Estimate</option>
    <option class="data-type" value="deaths_min">Minimum Death Estimate</option>
    <option class="data-type" value="civilians">Civilians</option>
    <option class="data-type" value="children">Children</option>
    <option class="data-type" value="injuries">Injuries</option>
  </select>
</div> -->
<!-- <div class="section" id="map-section">
  <h2>Geography</h2>
  <p>Hover over the timeline to learn about each individual strike. You can also click on the strikes to zoom into each region.</p>
  <div class="timeline"></div>
  <div class="map"></div>
</div> -->
<script src="javascripts/d3.v3.min.js"></script>
<script src="javascripts/topojson.v1.min.js"></script>
<script src="javascripts/d3.geo.projection.v0.min.js"></script>
<script src="javascripts/jquery-1.11.0.min.js"></script>
<script src="javascripts/d3.tip.v0.6.3.js"></script>
<script>

// Global variables

var width = $(".map").width(),
    height = $(".map").height(),
    padding = {top: 10, right: 20, bottom: 25, left: 20},
    active = d3.select(null),
    midLon = 56.9117872504883,
    midLat = 17.35921249538195,
    selectedDataType = "deaths_max",
    transitionTime = 1000

// TODO fix assignment of midLon, midLat
// projection is finishing before the assignment is finished...

// d3.json("data/drones.json", function(error, json) {
//   dataset = json.strike
//   var maxLon = d3.max(dataset, function(d) { return d.lon })
//   var minLon = d3.min(dataset, function(d) { return d.lon })
//   var maxLat = d3.max(dataset, function(d) { return d.lat })
//   var minLat = d3.min(dataset, function(d) { return d.lat })
  
//   midLon = (parseFloat(maxLon) + parseFloat(minLon)) / 2
//   midLat = (parseFloat(maxLat) + parseFloat(minLat)) / 2
// })


/*

Timeline by country

*/

// Set up
var sparklineWidth = $(".sparkline").width(),
    sparklineHeight = $(".sparkline").height(),
    dataTypes = ["deaths", "children", "civilians"],
    affectedCountries = ["Pakistan", "Yemen", "Somalia"],
    annualSums = {
        "deaths_max": [],
        "deaths_min": [],
        "children": [],
        "civilians": []
    },
    annualSums = {
        "deaths": [],
        "children": [],
        "civilians": []
    },
    padding = {
      "top": 20,
      "right": 20,
      "bottom": 20,
      "left": 20
    }

// Create containers for the annual sums
// sorry for the bad code :( im bad at programming
for (var i = 0; i < dataTypes.length; i++) {
  d3.selectAll("#" + dataTypes[i] + ".sparkline-wrapper").selectAll(".sparkline")
    .data(affectedCountries)
    .enter().append("div")
      .attr("class","sparkline")
      .attr("id", function(d) { return dataTypes[i] + " " + d })
};

// Draw annual sums
d3.json("data/drones.json", function(error, json) {
  var dataset = json.strike,
      xScale,
      yScale,
      yScaleDeathsMax

  // Calculate sum for each year for each data type
  var dataTypes = ["deaths", "children", "civilians"]
  for (var i = 0; i < dataTypes.length; i++) {
    annualSums[dataTypes[i]] = d3.nest()
      .key(function(d) { return d.country })
      .key(function(d) { return d.date.substring(0,4) })
      .rollup(function(d) { 
        return {
          "minimum": d3.sum(d, function(g) { {return getIntegerFromString(g[dataTypes[i]], "minimum")} }),
          "average": d3.sum(d, function(g) { {return getIntegerFromString(g[dataTypes[i]], "average")} }),
          "maximum": d3.sum(d, function(g) { {return getIntegerFromString(g[dataTypes[i]], "maximum")} })
        }
      }).entries(dataset)
  }

  // Bar chart variables
  var barWidth = ($(".sparkline").width() - 20) / (2014 - 2002),
      barHeight = 150,
      barHeight = $(".sparkline").height() - padding.top,
      yScaleDeaths = d3.scale.linear()
            .domain([0, getMaxOfDataType("deaths")])
            .range([barHeight - padding.bottom, 0]),
      yScaleChildren = d3.scale.linear()
            .domain([0, getMaxOfDataType("children")])
            .range([barHeight - padding.bottom, 0]),
      yScaleCivilians = d3.scale.linear()
            .domain([0, getMaxOfDataType("civilians")])
            .range([barHeight - padding.bottom, 0]),
      yScale = {
        "deaths": yScaleDeaths,
        "children": yScaleChildren,
        "civilians": yScaleCivilians
      }

  dataTypes = ["deaths", "children", "civilians"]

  // Draw out each yearly sum for each year, for each data type
  for (var i = 0; i < dataTypes.length; i++) {
    var currentYScale = yScale[dataTypes[i]]
    for (var j = 0; j < affectedCountries.length; j++) {
      var countryAnnualSum = annualSums[dataTypes[i]][j],
          countryName = countryAnnualSum.key,
          annualData = countryAnnualSum.values;

      // Draw error bars
      d3.select("#" + dataTypes[i] + ".sparkline-wrapper > " + "#" + countryName + ".sparkline").selectAll("line")
        .data(annualSums[dataTypes[i]][j].values).enter()
            .append("line")
            .attr("class", "error-bar")
            .attr("x1", function(d, i) { return (parseFloat(d.key) - 2002) * barWidth + padding.left })
            .attr("y1", function(d, i) { return currentYScale(d.values["maximum"]) - padding.bottom })
            .attr("x2", function(d, i) { return (parseFloat(d.key) - 2002) * barWidth + padding.left })
            .attr("y2", function(d, i) { return currentYScale(d.values["minimum"]) - padding.bottom })

      // Draw circles
      d3.select("#" + dataTypes[i] + ".sparkline-wrapper > " + "#" + countryName + ".sparkline").selectAll("circle")
        .data(annualSums[dataTypes[i]][j].values).enter()
          .append("circle")
            .attr("class", "sparkline")
            .attr("cx", function(d, i) { return (parseFloat(d.key) - 2002) * barWidth + padding.left })
            .attr("cy", function(d, i) { return currentYScale(d.values["average"]) - padding.bottom })
            .attr("r", 3)
    }
  }

  // TODO y axis
  var yAxis = {
    "deaths": [],
    "civilians": [],
    "children": [],
  },
      xAxis,
      xScale = d3.scale.linear()
        .domain([2002, 2014])
        .range([0, $(".sparkline").width()])

  // Calculate and draw y-axes
  for (var i = 0; i < dataTypes.length; i++) {

    xAxis = d3.svg.axis()
      .scale(xScale)
      .orient("bottom")
      .ticks(2)

    // Define y axis
    yAxis[dataTypes[i]] = d3.svg.axis()
      .scale(yScale[dataTypes[i]])
      .orient("left")
      .ticks(3)

    // y axis
    d3.select("#" + dataTypes[i] + ".sparkline-wrapper > " + "#Pakistan.sparkline")
      .append("g").call(yAxis[dataTypes[i]])
      .attr("transform", "translate(30,0)")
      .attr("class", "y axis")

    // x axis
    d3.selectAll(".sparkline")
      .append("g").call(xAxis)
      .attr("transform", "translate(0," + (sparklineHeight - padding.bottom) + ")")
      .attr("class", "x axis")
  }

  // Calculate and draw x-axes
  //   // Define and draw x-axis
  // var xAxis = d3.svg.axis()
  //   .scale(xScale)
  //   .orient("top")
  //   .ticks(10)

  // timeline.append("g")
  //   .attr("class", "axis")
  //   .attr("transform", "translate(10,2)")
  //   .call(xAxis)

})

// Get the maximum value from annualSums per dataType (deaths, civilians, children)
function getMaxOfDataType(dataType) {
  var array = []
  // console.log("dataType: " + dataType);
  for (var i = 0; i < annualSums[dataType].length; i++) {
    // console.log(annualSums[dataType][i]["key"]);
    for (var j = 0; j < annualSums[dataType][i].values.length; j++) {
      // console.log(annualSums[dataType][i].values[j]["key"] + ": " + annualSums[dataType][i].values[j].values["maximum"]);
    }
    array.push(d3.max(annualSums[dataType][i].values, function(d) { return d.values["maximum"] }))
  }
  // console.log("max: " + d3.max(array));
  // console.log("");
  return parseFloat(d3.max(array))
}

// Get integer from string, like it says on the box
function getIntegerFromString(input, operation) {
  // If blank input, return 0
  if (input == "") {
    return 0
  }
  if (input.lastIndexOf("-") == -1) {
    // If a single integer, return integer
    if (!isNaN(input)) {
      return parseFloat(input)
    // If some other string without "-", return 0
    } else {
      return 0
    }
  } else {
    var max = parseFloat(input.substring(input.lastIndexOf("-") + 1, input.length)),
        min = parseFloat(input.substring(0, input.lastIndexOf("-")))
    if (operation == "average") {
      // Not sure whether to round the avg...
      return (min + max) / 2
      return Math.floor((min + max) / 2)
    }
    else if (operation == "maximum") {
      return max
    }
    else if (operation == "minimum") {
      return min
    }
  }
}

// // Timeline variables
// var sparklineWidth = $(".timeline-by-country").width(),
//     sparklineHeight = $(".timeline-by-country").height(), 
//     xScale,
//     timeline,
//     dataset,
//     strikesOnTimeline,
//     timelineByCountry = d3.select(".timeline-by-country2")
//                           .append("svg")
//                           .attr("width", sparklineWidth)
//                           .attr("height", sparklineHeight)

// // Set up timeline
// d3.json("data/drones.json", function(error, json) {

//   timelineByCountry.selectAll(".g-sector")
//     .data(countryList)
//     .enter().append("div")
//       .attr("class", "g-sector")
//       .style()


//   var yAxisDistance = 100

//   dataset = json.strike
//   xScale = d3.time.scale()
//           .domain([new Date(dataset[0].date), new Date(dataset[dataset.length - 1].date)])
//           .range([padding.left, width - padding.right])

//   timelineByCountry.selectAll("rect")
//     .data(dataset)
//     .enter()
//     .append("rect")
//     .attr("x", function(d) { console.log(new Date(d.date).getFullYear()); return xScale(new Date(d.date)) })
//     .attr("y", function(d) { return sparklineHeight - d[selectedDataType] })
//     .attr("width", 2)
//     .attr("height", function(d) { return d[selectedDataType] })

//   // Define and draw x-axis
//   var xAxis = d3.svg.axis()
//     .scale(xScale)
//     .orient("top")
//     .ticks(10)

//   timeline.append("g")
//     .attr("class", "axis")
//     .attr("transform", "translate(10,2)")
//     .call(xAxis)
// })
</script>
<!--<script src="javascripts/map.js"></script>!-->