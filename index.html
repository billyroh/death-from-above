<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: 0 auto;
  padding: 60px;
  max-width: 1000px;
  min-width: 320px;
}

h1, h2 {
  font-weight: 300;
}

h1, h2, p {
  text-align: center;
}

.map {
  width: 100%;
  height: 600px;
  display: block;
  border: 1px solid rgba(0, 0, 0, 0.3);
}

.background {
  fill: none;
  pointer-events: all;
}

.feature {
  fill: #ccc;
  cursor: pointer;
}

circle {
  
}

.tooltip {
  width: 300px;
  height: 300px;
  background-color: red;
}

circle.strike, circle.timeline-circle {
  fill: rgb(200, 18, 18);
  opacity: 0.2;
  cursor: pointer;
}

.feature.active {
  
}

.mesh {
  fill: none;
  stroke: #fff;
  stroke-width: 0.5px;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.country-name {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  fill: #000;
  opacity: 0.3;
  margin-left: -10px;
  font-size: 11px;
  text-transform: uppercase;
  cursor: default;
}

/* Timeline stuff */ 

.timeline {
  width: 100%;
  height: 30px;
  margin-top: 10px;
}

.axis path,
.axis line {
  fill: none;
  stroke: black;
  shape-rendering: crispEdges;
}

.axis path {
  stroke: none;
}

.axis text {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 11px;
  cursor: default;
}


.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

</style>
<body>
<div class="text" id="intro">
  <h1>Death from Above</h1>
  <p>Mapping deaths from drone strikes.</p>
</div>
<div class="section" id="map-section">
  <h2>By Latitude, Longitude</h2>
  <p>Hover over the timeline to learn about each individual strike. You can also click on the strikes to zoom into each region.</p>
  <div class="timeline"></div>
  <div class="map"></div>
</div>
<div class="section" id="timeline-section">
  <!--

  * x axis: time
  * y axis: country

  * stack each country's timeline, plot each strike along its x axis
  * have control to toggle radius scaled to magnitude of each strike
  * able to switch datasets to display deaths_max, deaths_min, civilians, children

   -->
  <h2>By Country</h2>
  <p>Each circle corresponds to a single strike.</p>
</div>
<div class="section" id="timeline-section">
  <!--

  x axis: time
  y axis: country

  stack each country's timeline, plot each strike along its x axis
  have control to toggle radius scaled to magnitude of each strike

   -->
  <h2>By Country</h2>
  <p>Each circle corresponds to a single strike.</p>
</div>
<script src="javascripts/d3.v3.min.js"></script>
<script src="javascripts/topojson.v1.min.js"></script>
<script src="javascripts/d3.geo.projection.v0.min.js"></script>
<script src="javascripts/jquery-1.11.0.min.js"></script>
<script src="javascripts/d3.tip.v0.6.3.js"></script>
<script>

var width = $(".map").width(),
    height = $(".map").height(),
    padding = {top: 10, right: 20, bottom: 25, left: 20},
    active = d3.select(null);

var midLon = 56.9117872504883 ,
    midLat = 17.35921249538195,
    projection

// TODO fix assignment of midLon, midLat
// projection is finishing before the assignment is finished...

// function assignLonLat(lon, lat) {
//   console.log(lon + ", " + lat)
//   midLon = lon
//   midLat = lat
//   console.log("lon: " + midLon)
//   console.log("lat: " + midLat)
// }

// d3.json("data/drones.json", function(error, json) {
//   dataset = json.strike
//   var maxLon = d3.max(dataset, function(d) { return d.lon })
//   var minLon = d3.min(dataset, function(d) { return d.lon })
//   var maxLat = d3.max(dataset, function(d) { return d.lat })
//   var minLat = d3.min(dataset, function(d) { return d.lat })
  
//   midLon = (parseFloat(maxLon) + parseFloat(minLon)) / 2
//   midLat = (parseFloat(maxLat) + parseFloat(minLat)) / 2
//   assignLonLat(midLon, midLat)
// })

var projection = d3.geo.kavrayskiy7()
    .center([midLon, midLat])
    .scale(600)
    //.translate([width / 3.5, height / 5])

var zoom = d3.behavior.zoom()
    .translate([0, 0])
    .scale(1)
    .scaleExtent([1, 8])
    .on("zoom", zoomed);

var path = d3.geo.path()
    .projection(projection);

var svg = d3.select(".map").append("svg")
    .attr("width", width)
    .attr("height", height)
    // .on("click", stopped, true);

svg.append("rect")
    .attr("class", "background")
    .attr("width", width)
    .attr("height", height)
    .on("click", reset);

var g = svg.append("g")


//// TODO actually implement tooltips
var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    console.log("test");
    return "<strong>Frequency:</strong> <span style='color:red'>" + d.deaths_max + "</span>";
  })
//// TODO actually implement tooltips
g.call(tip)

svg
    //.call(zoom) // delete this line to disable free zooming
    .call(zoom.event);

d3.json("data/readme-world-names.json", function(error, world) {
  var countries = topojson.feature(world, world.objects.countries).features
  g.selectAll("path")
      .data(countries)
    .enter().append("path")
      .attr("d", path)
      .attr("class", "feature")
      .attr("id", function(d) { return d.id.replace(" ", "-") })
      .on("click", clicked)

  g.append("path")
      .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
      .attr("class", "mesh")
      .attr("d", path);

  // TODO make the country the country-name's parent node...
  // Label country names
  g.selectAll(".country-name")
    .data(countries)
  .enter().append("text")
    .attr("class", function(d) { return "country-name" })
    .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
    .attr("dx", "-1.5em")
    .text(function(d) { return d.id; });
})

// Set the max radius for the strikes
var radiusMax = 50,
    circleOpacityHighlight = 0.5,
    circleOpacityDefault = 0.2,
    circleOpacitySuppressed = 0.01

function isNumber(n){
  return typeof(n) != "boolean" && !isNaN(n);
}

function reset() {
  active.classed("active", false);
  active = d3.select(null);

  svg.transition()
      .duration(transitionTime)
      .call(zoom.translate([0, 0]).scale(1).event);
}

function zoomed() {
  g.style("stroke-width", 1.5 / d3.event.scale + "px");
  g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

// If the drag behavior prevents the default click,
// also stop propagation so we donâ€™t click-to-zoom.
function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

var affectedCountries = []

d3.json("data/drones.json", function(error, json) {
  dataset = json.strike
  yScale = d3.scale.linear()
        .domain([0, d3.max(dataset, function(d) { if(isNumber(d.deaths_max)) { return parseInt(d.deaths_max) } else { return 0 } })])
        .range([5, radiusMax])

  // Draw circles on map
  g.selectAll("circle")
    .data(dataset)
    .enter()
    .append("circle")
      .attr("class", "strike")
      .attr("id", function(d) { if (jQuery.inArray(d.country, affectedCountries) == -1) { affectedCountries.push(d.country) } ; return d._id })
      .attr("r", function(d) { if(!isNumber(d.deaths_max)) { return 0 } return yScale(d.deaths_max) } )
      .attr("transform", function(d) { return "translate(" + projection([d.lon, d.lat]) + ")" } )
      .style("opacity", circleOpacityDefault)
      .on("click", function(d) { return $("#" + d.country.replace(" ", "-")).d3Click() } )
      //// TODO actually implement tooltips
      .on("mouseover", function(d) { tip.show; highlightStrike("map", d._id) } )
      .on("mouseout", function(d) { tip.hide; $("circle.timeline-circle").css("opacity", circleOpacityDefault) } )

})

var transitionTime = 1000

function clicked(d) {
  console.log("")
  console.log("clicked")
  console.log(d)
  if (active.node() === this || jQuery.inArray(d.id, affectedCountries) == -1) {
    scaleCircles(1)
    console.log("reset")
    $(".timeline-circle").css("opacity", circleOpacityDefault)
    $(".timeline-circle").css("display", "block")
    return reset()
  }

  active.classed("active", false);
  active = d3.select(this).classed("active", true);
  
  var bounds = path.bounds(d),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      scale = .9 / Math.max(dx / width, dy / height),
      translate = [width / 2 - scale * x, height / 2 - scale * y],
      circleScaleValue = 1 / scale

  svg.transition()
      .duration(transitionTime)
      .call(zoom.translate(translate).scale(scale).event)

  scaleCircles(circleScaleValue)

  // Fade out the strikes in the timeline not in country
  $(".timeline-circle").css("opacity", 0)
  $(".timeline-circle").css("display", "none")
  $(".timeline-" + d.id.replace(" ", "-")).css("opacity", circleOpacityDefault)
  $(".timeline-" + d.id.replace(" ", "-")).css("display", "block")
}

function scaleCircles(circleScaleValue) {
  var opacityValue = 0.5
  if (circleScaleValue == 1) {
    opacityValue = 1
  }
  g.selectAll(".strike")
    .transition()
    .duration(transitionTime)
    .attr("r", function(d) { if(!isNumber(d.deaths_max)) { return 0 } return yScale(d.deaths_max) * circleScaleValue })
  
  g.selectAll(".feature")
    .transition()
    .duration(transitionTime)
    .style("opacity", opacityValue)

  g.selectAll(".feature.active")
    .transition()
    .duration(transitionTime)
    .style("opacity", 1)
}

// Dispatches click event for d3 objects
jQuery.fn.d3Click = function () {
  this.each(function (i, e) {
    var evt = document.createEvent("MouseEvents")
    evt.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null)
    e.dispatchEvent(evt);
  })
}

//// Set up timeline
var timelineWidth = $(".timeline").width(),
    timelineHeight = $(".timeline").height(), 
    xScale,
    timeline,
    dataset

timeline = d3.select(".timeline").append("svg")
        .attr("width", timelineWidth)
        .attr("height", timelineHeight)

d3.json("data/drones.json", function(error, json) {
  dataset = json.strike
  xScale = d3.time.scale()
          .domain([new Date(dataset[0].date), new Date(dataset[dataset.length - 1].date)])
          .range([padding.left, width - padding.right])

  timeline.selectAll("circle")
    .data(dataset)
    .enter()
    .append("circle")
    .attr("class", function(d) { return ("timeline-circle timeline-" + d.country) })
    .attr("id", function(d) { return "timeline-" + d._id })
    .attr("r", 3)
    .attr("cx", function(d) { return xScale(new Date(d.date)) })
    .attr("cy", 18)
    .on("mouseover", function(d) { return highlightStrike("timeline", d._id) } )
    .on("mouseout", function(d) { $("circle.strike").css("opacity", 0.2) } )
    .on("click", function(d) { return $("#" + d.country.replace(" ", "-")).d3Click() } )

  // Define and draw x-axis
  var xAxis = d3.svg.axis()
    .scale(xScale)
    .orient("top")
    .ticks(10)

  timeline.append("g")
    .attr("class", "axis")
    .attr("transform", "translate(10," + (timelineHeight - padding.top) + ")")
    .call(xAxis)
})

function highlightStrike(context, id) {
  var className = "strike",
      idName = ""

  if (context == "map") {
    className = "timeline-circle"
    idName = "timeline-"
  }

  $("circle." + className).css("opacity", circleOpacitySuppressed)
  $("circle#" + idName + id).css("opacity", circleOpacityHighlight)
  // $()
}

</script>
