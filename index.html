<!DOCTYPE html>
<meta charset="utf-8">
<head>
<title>Death from Above</title>
<style>

body {
  font-family: Georgia, "Times New Roman", serif;
  color: #454545;
  margin: 0 auto;
  padding: 20px;
  max-width: 945px;
  min-width: 320px;
}

h1, h2 {
  font-weight: 300;
}

h1, h2, p {
}

.section {
  display: block;
}

/* Sparklines */

.country-label, .sparkline {
  /*width: 300px;
  float: left;
  margin-right: 20px;*/
  width: 100%;
}

.country-label {
  font-size: 12px;
  text-transform: uppercase;
}

.country-label-wrapper {
  display: block;
}

.sparkline-wrapper {
  display: block;
  margin-bottom: 20px;
  /*height: 200px;*/
}

.sparkline, .sparkline-full {
  height: 300px;
  display: block;
}

.sparkline:last-child {
  margin-right: 0px;
}

.data-type-label {
  margin-bottom: 10px;
}

/* Sparkline Stuff */

circle.sparkline, circle.timeline {
  fill: #fff;
  stroke: #000;
  stroke-width: 2px;
  stroke-linecap: round;
  stroke-linejoin: round;
}

circle.sparkline#Yemen, circle.timeline#Yemen {
  stroke: #1b9e77;
}

circle.sparkline#Pakistan, circle.timeline#Pakistan {
  stroke: #d95f02;
}

circle.sparkline#Somalia, circle.timeline#Somalia {
  stroke: #7570b3;
}

line.error-bar, line.connector {
  fill: #fff;
  stroke: #000;
  stroke-width: 2px;
  stroke-linecap: round;
  stroke-linejoin: round;
  opacity: 0.5;
}

line.connector {
  opacity: 0.25;
}

line.error-bar#Yemen, line.connector#Yemen {
  stroke: #1b9e77;
}

line.error-bar#Pakistan, line.connector#Pakistan {
  stroke: #d95f02;
}

line.error-bar#Somalia, line.connector#Somalia {
  stroke: #7570b3;
}

line {
  stroke: #000;
}

line.sparkline, line.sparkline-full {
  stroke: #000;
}

/* Map Stuff */

.map {
  width: 100%;
  height: 600px;
  display: block;
  border: 1px solid rgba(0, 0, 0, 0.3);
}

.background {
  fill: none;
  pointer-events: all;
}

.feature {
  fill: #ccc;
  /*cursor: pointer;*/
}

.tooltip {
  width: 300px;
  height: 300px;
  background-color: red;
}

circle.strike, circle.timeline-circle {
  fill: rgb(200, 18, 18);
  opacity: 0.2;
  cursor: pointer;
  -webkit-transition: all 150ms;
  transition: all 150ms;
}

.feature.active {
  
}

.mesh {
  fill: none;
  stroke: #fff;
  stroke-width: 0.5px;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.country-name {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  fill: #000;
  opacity: 0.3;
  margin-left: -10px;
  font-size: 11px;
  text-transform: uppercase;
  cursor: default;
}

/* Timeline stuff */ 

.timeline-old {
  width: 100%;
  height: 30px;
  margin-top: 10px;
}

.timeline {
  width: 600px;
  height: 300px;
  /*width: 300px;
  height: 600px;*/
}

.timeline-by-country {
  width: 100%;
  height: 200px;
}

.timeline-wrapper {
  margin-bottom: 20px;
}

.timeline-country-label {
  margin-bottom: 10px;
}

.axis path,
.axis line {
  fill: none;
  stroke: black;
  shape-rendering: crispEdges;
}

.y.axis path {
  stroke: none;
}

.x.axis path {
  /*stroke: none;*/
}

.axis text, text.axis {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 11px;
  cursor: default;
}

.axis line {
  stroke: #777;
  stroke-dasharray: 2,2;
}


circle.not-applicable {
  opacity: 0;
  /*display: none;*/
}

/* Tooltip shit */

.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

/* Timeline maps */

.subunit.PAK, .hello { fill: #ddc; }

.subunit-boundary {
  fill: none;
  stroke: #777;
  stroke-dasharray: 2,2;
  stroke-linejoin: round;
}

.subunit-boundary.IRL {
  stroke: #aaa;
}

.place,
.place-label {
  fill: #444;
}

text {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 10px;
  pointer-events: none;
}

svg.country {
  fill: #000;
  /*background: #000;*/
}

svg.timeline {
  float: left;
}

svg.timeline-map {
  float: left;
}

</style>
</head>
<body>
<div class="text" id="intro">
  <h1>Death from Above</h1>
  <p>Mapping deaths from drone strikes.</p>
</div>
<div class="section" id="annual-sums-by-country">
  <h2>Timelines</h2>
  <p>Each circle corresponds to a single strike.</p>
  <div class="sparkline-wrapper">
    <div class="data-type-label">Overall Death Estimate</div>
    <svg class="sparkline" id="deaths"></svg>
  </div>
  <div class="sparkline-wrapper">
    <div class="data-type-label">Civilian Death Estimate</div>
    <svg class="sparkline" id="civilians"></svg>
  </div>
  <div class="sparkline-wrapper">
    <div class="data-type-label">Child Death Estimate</div>
    <svg class="sparkline" id="children"></svg>
  </div>
</div>
<div class="section" id="timeline-by-country">
  <div class="timeline-wrapper">
    <div class="timeline-country-label" id="Pakistan">Pakistan</div>
    <svg class="timeline" id="Pakistan"></svg>
    <svg class="timeline-map" id="Pakistan"></svg>
  </div>
  <div class="timeline-wrapper">
    <div class="timeline-country-label" id="Yemen">Yemen</div>
    <svg class="timeline" id="Yemen"></svg>
    <svg class="timeline-map" id="Yemen"></svg>
  </div>
  <div class="timeline-wrapper">
    <div class="timeline-country-label" id="Somalia">Somalia</div>
    <svg class="timeline" id="Somalia"></svg>
    <svg class="timeline-map" id="Somalia"></svg>
  </div>
</div>
<!-- </div>
<div class="data-type-selector-wrapper">
  <select class="data-type-selector">
    <option class="data-type" value="deaths_max" selected="selected">Maximum Death Estimate</option>
    <option class="data-type" value="deaths_min">Minimum Death Estimate</option>
    <option class="data-type" value="civilians">Civilians</option>
    <option class="data-type" value="children">Children</option>
    <option class="data-type" value="injuries">Injuries</option>
  </select>
</div> -->
<!-- <div class="section" id="map-section">
  <h2>Geography</h2>
  <p>Hover over the timeline to learn about each individual strike. You can also click on the strikes to zoom into each region.</p>
  <div class="timeline"></div>
  <div class="map"></div>
</div> -->
<script src="javascripts/d3.v3.min.js"></script>
<script src="javascripts/topojson.v1.min.js"></script>
<script src="javascripts/d3.geo.projection.v0.min.js"></script>
<script src="javascripts/jquery-1.11.0.min.js"></script>
<script src="javascripts/d3.tip.v0.6.3.js"></script>
<script src="javascripts/minimap.js"></script>
<script>

/*

Timeline by country

*/

// Set up
var sparklineWidth = $(".sparkline").width(),
    sparklineHeight = $(".sparkline").height(),
    dataTypes = ["deaths", "children", "civilians"],
    affectedCountries = ["Yemen", "Pakistan", "Somalia"],
    annualSums = {
        "deaths_max": [],
        "deaths_min": [],
        "children": [],
        "civilians": []
    },
    annualSums = {
        "deaths": [],
        "children": [],
        "civilians": []
    },
    padding = {
      "top": 20,
      "right": 20,
      "bottom": 20,
      "left": 40
    }

// Create containers for the annual sums
// sorry for the bad code :( im bad at programming
for (var i = 0; i < dataTypes.length; i++) {
  d3.selectAll("#" + dataTypes[i] + ".sparkline-wrapper").selectAll(".sparkline")
    .data(affectedCountries)
    .enter().append("div")
      .attr("class","sparkline")
      .attr("id", function(d) { return dataTypes[i] + " " + d })
};

jQuery.removeFromArray = function(value, arr) {
    return jQuery.grep(arr, function(elem, index) {
        return elem !== value;
    });
};

// Draw annual sums
d3.json("data/drones.json", function(error, json) {
  var dataset = json.strike,
      xScale,
      yScale,
      yScaleDeathsMax

  // Calculate sum for each year for each data type
  var dataTypes = ["deaths", "children", "civilians"]
  for (var i = 0; i < dataTypes.length; i++) {
    annualSums[dataTypes[i]] = d3.nest()
      .key(function(d) { return d.country })
      .key(function(d) { return d.date.substring(0,4) })
      .rollup(function(d) {
        return {
          "minimum": d3.sum(d, function(g) { {return getIntegerFromString(g[dataTypes[i]], "minimum")} }),
          "average": d3.sum(d, function(g) { {return getIntegerFromString(g[dataTypes[i]], "average")} }),
          "maximum": d3.sum(d, function(g) { {return getIntegerFromString(g[dataTypes[i]], "maximum")} })
        }
      }).entries(dataset)
  }

  // For years when there are no strikes, add in 0
  for (var i = 0; i < dataTypes.length; i++) {
    var tempArray = [],
        missingYears = []
        
    for (var j = 0; j < annualSums[dataTypes[i]].length; j++) {
      var yearArray = []
      for (var year = 2002; year < 2015; year++) {
        yearArray.push("" + year)
      }
      // Check which years haven't been covered
      for (var k = 0; k < annualSums[dataTypes[i]][j].values.length; k++) { // this is getting out of hand
        yearArray = jQuery.removeFromArray(annualSums[dataTypes[i]][j].values[k].key, yearArray)
      }
      // Insert 0 for each of those empty years
      for (var k = 0; k < yearArray.length; k++ ) {
        var year = {
          key: "" + yearArray[k],
          values: {
            minimum: 0,
            average: 0,
            maximum: 0
          }
        }
        annualSums[dataTypes[i]][j].values.push(year)
      }
      annualSums[dataTypes[i]][j].values.sort(function(a, b) { return a.key - b.key }) // sort in ascending order
    }
  }

  // Chart variables
  var circleSpacing = ($(".sparkline").width() - padding.right + 13) / (2014 - 2002),
      sparklineHeight = $(".sparkline").height() - padding.top,
      yScaleDeaths = d3.scale.linear()
            .domain([0, getMaxOfDataType("deaths")])
            .range([sparklineHeight - padding.bottom, 0]),
      yScaleChildren = d3.scale.linear()
            .domain([0, getMaxOfDataType("children")])
            .range([sparklineHeight - padding.bottom, 0]),
      yScaleCivilians = d3.scale.linear()
            .domain([0, getMaxOfDataType("civilians")])
            .range([sparklineHeight - padding.bottom, 0]),
      yScale = {
        "deaths": yScaleDeaths,
        "children": yScaleChildren,
        "civilians": yScaleCivilians
      },
      selector = {
        "deaths": d3.select(".sparkline#deaths"),
        "children": d3.select(".sparkline#children"),
        "civilians": d3.select(".sparkline#civilians")
      }
      sparklineLineSelector = {
        "deaths": selector["deaths"].selectAll("line"),
        "children": selector["children"].selectAll("line"),
        "civilians": selector["civilians"].selectAll("line")
      }

  // y axis
  var yAxis = {
    "deaths": [],
    "civilians": [],
    "children": [],
    },
      xAxis,
      xScale = d3.scale.linear()
        .domain([2002, 2014])
        .range([0, $(".sparkline").width()])

  // Calculate and draw y axes
  for (var i = 0; i < dataTypes.length; i++) {
      for (var j = 0; j < affectedCountries.length; j++) {
        // Define y axis
        yAxis[dataTypes[i]] = d3.svg.axis()
          .scale(yScale[dataTypes[i]])
          .orient("left")
          .ticks(6)
          .tickSize(sparklineWidth)

        var currentSelector = selector[dataTypes[i]]
          .append("g").call(yAxis[dataTypes[i]])
        
        currentSelector.attr("transform", "translate(" + (sparklineWidth) + "," + padding.top + ")")
          .attr("class", "y axis")

        currentSelector.selectAll("text")
          .attr("x", 0)
          .attr("text-align", "right")

        if (j != affectedCountries.length - 1) {
          currentSelector.selectAll("text")
            .attr("display", "none")
        }
      }
  }

  // Draw x axes
  d3.selectAll(".sparkline")
    .append("line")
    .attr("class", "x axis")
    .attr("x1", 0)
    .attr("y1", sparklineHeight)
    .attr("x2", sparklineWidth)
    .attr("y2", sparklineHeight)

  d3.selectAll(".sparkline")
    .append("text")
    .attr("class", "axis start-date")
    .attr("x", 0)
    .attr("y", sparklineHeight + padding.bottom - 3)
    .text("2002")

  d3.selectAll(".sparkline")
    .append("text")
    .attr("class", "axis end-date")
    .attr("x", sparklineWidth - padding.left - padding.right + 15)
    .attr("y", sparklineHeight + padding.bottom - 3)
    .text("2014")

  // Put each country annual sum data into graph, separate by dataType
  for (var dataTypesIndex = 0; dataTypesIndex < dataTypes.length; dataTypesIndex++) {
    var lineSelector = d3.select(".sparkline#" + dataTypes[dataTypesIndex]).selectAll("line"),
        circleSelector = d3.select(".sparkline#" + dataTypes[dataTypesIndex]).selectAll("circle"),
        currentYScale = yScale[dataTypes[dataTypesIndex]]
    for (var affectedCountriesIndex = 0; affectedCountriesIndex < affectedCountries.length; affectedCountriesIndex++) {

      sparklineLineSelector[dataTypes[dataTypesIndex]]
        .data(annualSums[dataTypes[dataTypesIndex]][affectedCountriesIndex].values).enter()
          .append("line")
            .attr("class", "connector")
            .attr("id", annualSums[dataTypes[dataTypesIndex]][affectedCountriesIndex].key)
            .attr("x1", function(d, i) { if (parseFloat(d.key) == 2014) { return -100 }; return (parseFloat(d.key) - 2002) * circleSpacing + 3 })
            .attr("y1", function(d, i) { if (parseFloat(d.key) == 2014) { return -100 }; return currentYScale(d.values["average"]) + padding.top })
            .attr("x2", function(d, i) { if (parseFloat(d.key) == 2014) { return -100 }; return (parseFloat(d.key) - 2002 + 1) * circleSpacing + 3 })
            .attr("y2", function(d, i) { if (parseFloat(d.key) == 2014) { return -100 }; return currentYScale(annualSums[dataTypes[dataTypesIndex]][affectedCountriesIndex].values[i + 1].values["average"]) + padding.top })

      // Draw error bars
      sparklineLineSelector[dataTypes[dataTypesIndex]]
        .data(annualSums[dataTypes[dataTypesIndex]][affectedCountriesIndex].values).enter()
          .append("line")
            .attr("class", "error-bar")
            .attr("id", annualSums[dataTypes[dataTypesIndex]][affectedCountriesIndex].key)
            .attr("x1", function(d) { return (parseFloat(d.key) - 2002) * circleSpacing + 3 })
            .attr("y1", function(d) { return currentYScale(d.values["maximum"]) + padding.top })
            .attr("x2", function(d) { return (parseFloat(d.key) - 2002) * circleSpacing + 3 })
            .attr("y2", function(d) { return currentYScale(d.values["minimum"]) + padding.top })

      // Draw circles
      circleSelector
        .data(annualSums[dataTypes[dataTypesIndex]][affectedCountriesIndex].values).enter()
          .append("circle")
            .attr("class", "sparkline")
            .attr("id", annualSums[dataTypes[dataTypesIndex]][affectedCountriesIndex].key)
            .attr("cx", function(d) { return (parseFloat(d.key) - 2002) * circleSpacing + 3 })
            .attr("cy", function(d) { return currentYScale(d.values["average"]) + padding.top })
            .attr("r", 2)
            .attr("value", function(d) { return d.values["average"] })
            .attr("year", function(d) { return d.key })
            .on("mouseover", function(d) { displayYear(d.key) })
            .on("mouseout", function(d) { resetYear() })
    }
  }

})

function displayYear(year) {
  d3.selectAll(".sparkline-wrapper > .sparkline").selectAll(".start-date")
    .text("" + year)
    .attr("transform", "translate(0, 0)")
}

function resetYear() {
  d3.selectAll(".sparkline-wrapper > .sparkline").selectAll(".start-date")
    .text("2012")
    .attr("transform", "translate(0,0)")
  // return
}

// Get the maximum value from annualSums per dataType (deaths, civilians, children)
function getMaxOfDataType(dataType) {
  var array = []
  for (var i = 0; i < annualSums[dataType].length; i++) {
    for (var j = 0; j < annualSums[dataType][i].values.length; j++) {
    }
    array.push(d3.max(annualSums[dataType][i].values, function(d) { return d.values["maximum"] }))
  }
  return parseFloat(d3.max(array))
}

// Get integer from string, like it says on the box
function getIntegerFromString(input, operation) {
  // If blank input, return 0
  if (input == "") {
    return 0
  }
  if (input.lastIndexOf("-") == -1) {
    // If a single integer, return integer
    if (!isNaN(input)) {
      return parseFloat(input)
    // If some other string without "-", return 0
    } else {
      return 0
    }
  } else {
    var max = parseFloat(input.substring(input.lastIndexOf("-") + 1, input.length)),
        min = parseFloat(input.substring(0, input.lastIndexOf("-")))
    if (operation == "average") {
      // Not sure whether to round the average or not...
      return (min + max) / 2
      return Math.floor((min + max) / 2)
    }
    else if (operation == "maximum") {
      return max
    }
    else if (operation == "minimum") {
      return min
    }
  }
}

/* 
      Timeline by country
*/

var padding = {
      "top": 20,
      "right": 20,
      "bottom": 20,
      "left": 20
    },
    timelineWidth = $(".timeline").width(),
    timelineHeight = $(".timeline").height()


/*
      Draw mini-maps
*/

var width = 300,
    height = 300;

var projection = {
  "Pakistan": d3.geo.mercator()
    .center([79.1, 22])
    .scale(900)
    .translate([width, height]),
  "Yemen": d3.geo.mercator()
    .center([55, 9.25])
    .scale(1320)
    .translate([width, height]),
  "Somalia":d3.geo.mercator()
    .center([54.2, -2.5])
    .scale(1100)
    .translate([width, height])
}

var path = {
  "Pakistan": d3.geo.path()
    .projection(projection["Pakistan"])
    .pointRadius(2),
  "Yemen": d3.geo.path()
    .projection(projection["Yemen"])
    .pointRadius(2),
  "Somalia": d3.geo.path()
    .projection(projection["Somalia"])
    .pointRadius(2)
}

// // TODO why won't this work????????!??!?!?!?!?!?!
// for (var i = 0; i < affectedCountries.length; i++) {
//   var currentSelector = d3.select(".timeline-map#" + affectedCountries[i])
//         .attr("width", width)
//         .attr("height", height),
//       currentProjection = projection[affectedCountries[i]],
//       currentPathName = "data/" + affectedCountries[i].toLowerCase() + ".json"

//     console.log("");
//     console.log(affectedCountries[i]);
//     console.log(currentPathName);
//     console.log(currentSelector.selectAll(".subunit"));
//   // d3.json("data/pakistan.json", function(error, country) {
//   d3.json(("" + currentPathName), function(error, country) {
//     currentSelector.selectAll(".subunit")
//         .data(topojson.feature(country, country.objects.subunits).features)
//       .enter().append("path")
//         .attr("class", function(d) {console.log(d); return "subunit " + d.id; })
//         .attr("d", path[affectedCountries[i]]);

//     currentSelector.append("path")
//         .datum(topojson.feature(country, country.objects.subunits))
//         .attr("d", path[affectedCountries[i]])
//         .attr("class", "hello")

//     currentSelector.append("path")
//         .datum(topojson.feature(country, country.objects.places))
//         .attr("d", path[affectedCountries[i]])
//         .attr("class", "place");

//     currentSelector.selectAll(".place-label")
//         .data(topojson.feature(country, country.objects.places).features)
//       .enter().append("text")
//         .attr("class", "place-label")
//         .attr("transform", function(d) { return "translate(" + currentProjection(d.geometry.coordinates) + ")"; })
//         .attr("x", function(d) { return d.geometry.coordinates[0] > -1 ? 6 : -6; })
//         .attr("dy", ".35em")
//         .style("text-anchor", function(d) { return d.geometry.coordinates[0] > -1 ? "start" : "end"; })
//         .text(function(d) { return d.properties.name; });
//   });
// }

var pakistan = d3.select(".timeline-map#Pakistan")
    .attr("width", width)
    .attr("height", height);

var projectionPakistan = d3.geo.mercator()
    .center([79.1, 22])
    .scale(900)
    .translate([width, height]);

var pathPakistan = d3.geo.path()
    .projection(projectionPakistan)
    .pointRadius(2);

d3.json("data/pakistan.json", function(error, country) {
  pakistan.selectAll(".subunit")
      .data(topojson.feature(country, country.objects.subunits).features)
    .enter().append("path")
      .attr("class", function(d) { return "subunit " + d.id; })
      .attr("d", pathPakistan);

  pakistan.append("path")
      .datum(topojson.feature(country, country.objects.subunits))
      .attr("d", pathPakistan)
      .attr("class", "hello")

  pakistan.append("path")
      .datum(topojson.feature(country, country.objects.places))
      .attr("d", pathPakistan)
      .attr("class", "place");

  pakistan.selectAll(".place-label")
      .data(topojson.feature(country, country.objects.places).features)
    .enter().append("text")
      .attr("class", "place-label")
      .attr("transform", function(d) { return "translate(" + projectionPakistan(d.geometry.coordinates) + ")"; })
      .attr("x", function(d) { return d.geometry.coordinates[0] > -1 ? 6 : -6; })
      .attr("dy", ".35em")
      .style("text-anchor", function(d) { return d.geometry.coordinates[0] > -1 ? "start" : "end"; })
      .text(function(d) { return d.properties.name; });

  d3.json("data/drones.json", function(error, json) {
    dataset = json.strike
    pakistan.selectAll("circle")
      .data(dataset).enter()
        .append("circle")
        .attr("class", "strike")
        .attr("visibility", function(d) { if (d.country == "Pakistan") { return "ok" } else { return "hidden" } })
        .attr("r", 3)
        .attr("transform", function(d) { return "translate(" + projectionPakistan([d.lon, d.lat]) + ")" } )
  })

  pakistan.selectAll("circle[visibility = hidden]").remove()

});

var projectionYemen = d3.geo.mercator()
    .center([55, 9.25])
    .scale(1320)
    .translate([width, height]);

var pathYemen = d3.geo.path()
    .projection(projectionYemen)
    .pointRadius(2);

var yemen = d3.select(".timeline-map#Yemen")
    .attr("width", width)
    .attr("height", height);

d3.json("data/yemen.json", function(error, country) {
  yemen.selectAll(".subunit")
      .data(topojson.feature(country, country.objects.subunits).features)
    .enter().append("path")
      .attr("class", function(d) { return "subunit " + d.id; })
      .attr("d", pathYemen)
      // .attr("transform", "translate(200, -200)")

  yemen.append("path")
      .datum(topojson.feature(country, country.objects.subunits))
      .attr("d", pathYemen)
      .attr("class", "hello")

  yemen.append("path")
      .datum(topojson.feature(country, country.objects.places))
      .attr("d", pathYemen)
      .attr("class", "place");

  yemen.selectAll(".place-label")
      .data(topojson.feature(country, country.objects.places).features)
    .enter().append("text")
      .attr("class", "place-label")
      .attr("transform", function(d) { return "translate(" + projectionYemen(d.geometry.coordinates) + ")"; })
      .attr("x", function(d) { return d.geometry.coordinates[0] > -1 ? 6 : -6; })
      .attr("dy", ".35em")
      .style("text-anchor", function(d) { return d.geometry.coordinates[0] > -1 ? "start" : "end"; })
      .text(function(d) { return d.properties.name; });

  d3.json("data/drones.json", function(error, json) {
    dataset = json.strike
    yemen.selectAll("circle")
      .data(dataset).enter()
        .append("circle")
        .attr("class", "strike")
        .attr("visibility", function(d) { if (d.country == "Yemen") { return "ok" } else { return "hidden" } })
        .attr("r", 3)
        .attr("transform", function(d) { return "translate(" + projectionYemen([d.lon, d.lat]) + ")" } )
  })

  yemen.selectAll("circle[visibility = hidden]").remove()

});

var projectionSomalia = d3.geo.mercator()
    .center([54.2, -2.5])
    .scale(1100)
    .translate([width, height]);

var pathSomalia = d3.geo.path()
    .projection(projectionSomalia)
    .pointRadius(2);

var somalia = d3.select(".timeline-map#Somalia")
    .attr("width", width)
    .attr("height", height);

d3.json("data/somalia.json", function(error, country) {
  somalia.selectAll(".subunit")
      .data(topojson.feature(country, country.objects.subunits).features)
    .enter().append("path")
      .attr("class", function(d) { return "subunit " + d.id; })
      .attr("d", pathSomalia)

  somalia.append("path")
      .datum(topojson.feature(country, country.objects.subunits))
      .attr("d", pathSomalia)
      .attr("class", "hello")

  somalia.append("path")
      .datum(topojson.feature(country, country.objects.places))
      .attr("d", pathSomalia)
      .attr("class", "place");

  somalia.selectAll(".place-label")
      .data(topojson.feature(country, country.objects.places).features)
    .enter().append("text")
      .attr("class", "place-label")
      .attr("transform", function(d) { return "translate(" + pathSomalia(d.geometry.coordinates) + ")"; })
      .attr("x", 137)
      .attr("dy", "21.5em")
      .style("text-anchor", function(d) { return d.geometry.coordinates[0] > -1 ? "start" : "end"; })
      .text(function(d) { return d.properties.name; });

  d3.json("data/drones.json", function(error, json) {
    dataset = json.strike
    somalia.selectAll("circle")
      .data(dataset).enter()
        .append("circle")
        .attr("class", "strike")
        .attr("visibility", function(d) { if (d.country == "Somalia") { return "ok" } else { return "hidden" } })
        .attr("r", 3)
        .attr("transform", function(d) { return "translate(" + projectionSomalia([d.lon, d.lat]) + ")" } )
  })

  somalia.selectAll("circle[visibility = hidden]").remove()

});


/*

    Draw Timelines

*/


d3.json("data/drones.json", function(error, json) {
  var dataset = json.strike,
      yScale,
      xScale,
      xAxis

  xScale = d3.time.scale()
            .domain([new Date(dataset[0].date), new Date(dataset[dataset.length - 1].date)])
            .range([padding.left, timelineWidth - padding.right])

  yScale = d3.time.scale()
            .domain([0, 50])
            .range([timelineHeight - padding.top, padding.bottom])
  
  yScale = {
    "Pakistan": "",
    "Yemen": "",
    "Somalia": ""
  }

  for (var i = 0; i < affectedCountries.length; i++) {
    var currentYScale,
        currentTimeline = d3.select(".timeline#" + affectedCountries[i]),
        currentMax

    currentMax = d3.max(dataset, function(d) { if (d.country == affectedCountries[i]) { return getIntegerFromString(d.deaths, "maximum") } })

    yScale[affectedCountries[i]] = d3.scale.linear()
      .domain([0, currentMax])
      .range([timelineHeight - padding.top, padding.bottom])

    currentYScale = d3.scale.linear()
      .domain([0, currentMax])
      .range([timelineHeight - padding.top, padding.bottom])

    // Draw x axes
    xAxis = d3.svg.axis()
      .scale(xScale)
      .orient("bottom")
      .ticks(10)

    currentTimeline.append("g")
      .attr("class", "axis")
      .attr("transform", "translate(0," + (timelineHeight - padding.bottom) + ")")
      .call(xAxis)

    // Draw y axes
    yAxis = d3.svg.axis()
      .scale(currentYScale)
      .orient("left")
      .ticks(5)
      .tickSize(timelineWidth)

    currentTimeline.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(" + (timelineWidth + 30) + ",0)")
      .call(yAxis)

    // Error bars
    currentTimeline.selectAll("line")
      .data(dataset).enter()
        .append("line")
        .attr("class", "error-bar")
        .attr("id", function(d) { return d.country })
        .attr("visibility", function(d) { if (d.country != affectedCountries[i]) { return "hidden" } else { return "ok" } })
        .attr("x1", function(d) { return xScale(new Date(d.date)) })
        .attr("y1", function(d) { return (currentYScale(getIntegerFromString(d.deaths, "maximum"))) })
        .attr("x2", function(d) { return xScale(new Date(d.date)) })
        .attr("y2", function(d) { return (currentYScale(getIntegerFromString(d.deaths, "minimum"))) })

    // Draw circles
    currentTimeline.selectAll("circle")
      .data(dataset).enter()
        .append("circle")
        .attr("class", "timeline")
        .attr("visibility", function(d) { if (d.country != affectedCountries[i]) { return "hidden" } else { return "ok" } })
        .attr("id", function(d) { return d.country })
        .attr("cx", function(d) { return xScale(new Date(d.date)) })
        .attr("cy", function(d) { return (currentYScale(getIntegerFromString(d.deaths, "average"))) })
        .attr("r", function(d) { return 2 })

    // current

    // Get rid of hidden strikes
    currentTimeline.selectAll("circle[visibility = hidden]").remove()
    currentTimeline.selectAll("line[visibility = hidden]").remove()
  }

})


/*

Practice

*/

</script>
<!--<script src="javascripts/map.js"></script>!-->